$date
	Wed Mar 22 02:18:01 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module processor_tb $end
$var wire 32 ! reg1_data [31:0] $end
$var wire 32 " reg2_data [31:0] $end
$var wire 32 # write_reg_data [31:0] $end
$var wire 5 $ write_reg_addr [4:0] $end
$var wire 5 % reg2_addr [4:0] $end
$var wire 5 & reg1_addr [4:0] $end
$var wire 32 ' prog_count [31:0] $end
$var wire 6 ( instr_opcode [5:0] $end
$var reg 1 ) clk $end
$var reg 1 * rst $end
$var integer 32 + passedTests [31:0] $end
$var integer 32 , totalTests [31:0] $end
$scope module uut $end
$var wire 1 ) clk $end
$var wire 32 - datamuxwritedataout [31:0] $end
$var wire 32 . prog_count [31:0] $end
$var wire 32 / reg1_data [31:0] $end
$var wire 32 0 reg2_data [31:0] $end
$var wire 1 * rst $end
$var wire 1 1 step5muxand $end
$var wire 32 2 write_reg_data [31:0] $end
$var wire 1 3 zero $end
$var wire 32 4 writeregmuxout [31:0] $end
$var wire 5 5 write_reg_addr [4:0] $end
$var wire 32 6 step5muxchan2 [31:0] $end
$var wire 32 7 step4muxout [31:0] $end
$var wire 32 8 shiftleft2 [31:0] $end
$var wire 1 9 regwriteregwrite $end
$var wire 1 : regdstselectin $end
$var wire 32 ; regdata2 [31:0] $end
$var wire 32 < regdata1 [31:0] $end
$var wire 5 = reg2_addr [4:0] $end
$var wire 5 > reg1_addr [4:0] $end
$var wire 32 ? pcadderout [31:0] $end
$var wire 32 @ pc_out [31:0] $end
$var wire 32 A pc_in [31:0] $end
$var wire 1 B memwritedatamem $end
$var wire 1 C memtoregmux $end
$var wire 1 D memreaddatamem $end
$var wire 32 E instruction_out [31:0] $end
$var wire 6 F instr_opcode [5:0] $end
$var wire 1 G instr_extend $end
$var wire 32 H datamemmuxchan2 [31:0] $end
$var wire 1 I branchandmux $end
$var wire 1 J alusrcmux $end
$var wire 32 K aluout [31:0] $end
$var wire 2 L aluopaluctrl [1:0] $end
$var wire 32 M alumuxout [31:0] $end
$var wire 4 N aluctrloutalu [3:0] $end
$scope module ALU $end
$var wire 32 O channel_b_in [31:0] $end
$var wire 32 P channel_a_in [31:0] $end
$var wire 4 Q alu_control_in [3:0] $end
$var reg 32 R alu_result_out [31:0] $end
$var reg 32 S temp [31:0] $end
$var reg 1 3 zero_out $end
$upscope $end
$scope module ALUControl $end
$var wire 6 T instruction_5_0 [5:0] $end
$var wire 2 U alu_op [1:0] $end
$var reg 4 V alu_out [3:0] $end
$upscope $end
$scope module Control $end
$var wire 6 W instr_op [5:0] $end
$var reg 2 X alu_op [1:0] $end
$var reg 1 J alu_src $end
$var reg 1 I branch $end
$var reg 1 D mem_read $end
$var reg 1 C mem_to_reg $end
$var reg 1 B mem_write $end
$var reg 1 : reg_dst $end
$var reg 1 9 reg_write $end
$upscope $end
$scope module MuxAlu $end
$var wire 32 Y datain2 [31:0] $end
$var wire 1 J select_in $end
$var wire 32 Z datain1 [31:0] $end
$var wire 32 [ data_out [31:0] $end
$upscope $end
$scope module PC $end
$var wire 1 ) clk $end
$var wire 1 * rst $end
$var wire 1 ) write_en $end
$var wire 32 \ data_in [31:0] $end
$var reg 32 ] data_out [31:0] $end
$upscope $end
$scope module RAM $end
$var wire 1 ) clk $end
$var wire 8 ^ data_address [7:0] $end
$var wire 1 B data_mem_write $end
$var wire 32 _ data_read_data [31:0] $end
$var wire 32 ` instr_instruction [31:0] $end
$var wire 8 a instr_read_address [7:0] $end
$var wire 1 * rst $end
$var wire 32 b data_write_data [31:0] $end
$upscope $end
$scope module Registers $end
$var wire 1 ) clk $end
$var wire 32 c read_data_1 [31:0] $end
$var wire 32 d read_data_2 [31:0] $end
$var wire 5 e read_register_1 [4:0] $end
$var wire 5 f read_register_2 [4:0] $end
$var wire 1 9 reg_write $end
$var wire 1 * rst $end
$var wire 32 g write_data [31:0] $end
$var wire 5 h write_register [4:0] $end
$var integer 32 i i [31:0] $end
$upscope $end
$scope module Step5 $end
$var wire 4 j alu_control_in [3:0] $end
$var wire 32 k channel_b_in [31:0] $end
$var wire 32 l channel_a_in [31:0] $end
$var reg 32 m alu_result_out [31:0] $end
$var reg 32 n temp [31:0] $end
$var reg 1 o zero_out $end
$upscope $end
$scope module WriteRegMux $end
$var wire 32 p datain1 [31:0] $end
$var wire 32 q datain2 [31:0] $end
$var wire 1 : select_in $end
$var wire 32 r data_out [31:0] $end
$upscope $end
$scope module pc_adder $end
$var wire 4 s alu_control_in [3:0] $end
$var wire 32 t channel_a_in [31:0] $end
$var wire 32 u channel_b_in [31:0] $end
$var reg 32 v alu_result_out [31:0] $end
$var reg 32 w temp [31:0] $end
$var reg 1 x zero_out $end
$upscope $end
$scope module step4mux $end
$var wire 32 y datain1 [31:0] $end
$var wire 32 z datain2 [31:0] $end
$var wire 1 C select_in $end
$var wire 32 { data_out [31:0] $end
$upscope $end
$scope module step5mux $end
$var wire 32 | datain1 [31:0] $end
$var wire 32 } datain2 [31:0] $end
$var wire 1 1 select_in $end
$var wire 32 ~ data_out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100 ~
b10000000 }
b100 |
bx {
bx z
bx y
0x
b100 w
b100 v
b100 u
b0 t
b10 s
b10 r
b0 q
b10 p
0o
b10000000 n
b10000000 m
b100 l
b1111100 k
b10 j
bx i
b10 h
bz g
b10 f
b0 e
bx d
bx c
bx b
b0 a
b10001100000000100000000000011111 `
bx _
bx ^
b0 ]
b100 \
b11111 [
bx Z
b11111 Y
b0 X
b100011 W
b10 V
b0 U
b11111 T
bx S
bx R
b10 Q
bx P
b11111 O
b10 N
b11111 M
b0 L
bx K
1J
0I
bx H
1G
b100011 F
b10001100000000100000000000011111 E
1D
1C
0B
b100 A
b0 @
b100 ?
b0 >
b10 =
bx <
bx ;
0:
19
b1111100 8
bx 7
b10000000 6
b10 5
b10 4
x3
bx 2
01
bz 0
bz /
b0 .
bz -
b0 ,
b0 +
1*
0)
b100011 (
b0 '
b0 &
b10 %
b10 $
bx #
bz "
bz !
$end
#50000
b101101001 #
b101101001 2
b101101001 7
b101101001 {
b101101001 H
b101101001 _
b101101001 z
b11111 ^
03
b11111 K
b11111 R
b11111 y
b11111 S
b0 ;
b0 Z
b0 b
b0 d
b0 <
b0 P
b0 c
b100000 i
1)
#100000
0*
0)
#105000
b10101110 #
b10101110 2
b10101110 7
b10101110 {
b10101110 H
b10101110 _
b10101110 z
b100000 ^
b100000 K
b100000 R
b100000 y
b100000 S
b11 h
b11 $
b11 5
b10000000 8
b10000000 k
b100000 M
b100000 O
b100000 [
0G
b11 4
b11 r
b1000 A
b1000 \
b1000 ~
b10001000 6
b10001000 m
b10001000 }
b10001000 n
b100000 Y
b100000 T
b11 p
b11 %
b11 =
b11 f
b1000 ?
b1000 l
b1000 v
b1000 |
b1000 w
b10001100000000110000000000100000 E
b10001100000000110000000000100000 `
b1 a
b100 '
b100 .
b100 @
b100 ]
b100 t
b0 ;
b0 Z
b0 b
b0 d
1)
#110000
0)
#115000
b100 h
b100 $
b100 5
bx H
bx _
bx z
bx ^
b100 4
b100 r
bx #
bx 2
bx 7
bx {
b1000000010000000 8
b1000000010000000 k
bz M
bz O
bz [
x3
bx K
bx R
bx y
bx S
b10 L
b10 U
b10 X
1:
19
0J
0C
0D
b1100 A
b1100 \
b1100 ~
b1000000010001100 6
b1000000010001100 m
b1000000010001100 }
b1000000010001100 n
b10000000100000 Y
b100 q
bz <
bz P
bz c
b10 &
b10 >
b10 e
b0 (
b0 F
b0 W
b1100 ?
b1100 l
b1100 v
b1100 |
b1100 w
b10000110010000000100000 E
b10000110010000000100000 `
b10 a
b1000 '
b1000 .
b1000 @
b1000 ]
b1000 t
bz ;
bz Z
bz b
bz d
1)
#116000
b1 ,
#120000
0)
#125000
b1100100 M
b1100100 O
b1100100 [
b110010000 8
b110010000 k
1J
19
b0 L
b0 U
b0 X
0:
b10000 A
b10000 \
b10000 ~
b110100000 6
b110100000 m
b110100000 }
b110100000 n
b1100100 Y
b100100 T
b0 q
b100 p
b100 %
b100 =
b100 f
b1000 (
b1000 F
b1000 W
b10000 ?
b10000 l
b10000 v
b10000 |
b10000 w
b100000010001000000000001100100 E
b100000010001000000000001100100 `
b11 a
b1100 '
b1100 .
b1100 @
b1100 ]
b1100 t
1)
#126000
b10 ,
