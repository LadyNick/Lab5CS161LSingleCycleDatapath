$date
	Thu Mar 23 05:58:06 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module processor_tb $end
$var wire 32 ! reg1_data [31:0] $end
$var wire 32 " reg2_data [31:0] $end
$var wire 32 # write_reg_data [31:0] $end
$var wire 5 $ write_reg_addr [4:0] $end
$var wire 5 % reg2_addr [4:0] $end
$var wire 5 & reg1_addr [4:0] $end
$var wire 32 ' prog_count [31:0] $end
$var wire 6 ( instr_opcode [5:0] $end
$var reg 1 ) clk $end
$var reg 1 * rst $end
$var integer 32 + passedTests [31:0] $end
$var integer 32 , totalTests [31:0] $end
$scope module uut $end
$var wire 1 ) clk $end
$var wire 32 - prog_count [31:0] $end
$var wire 32 . reg1_data [31:0] $end
$var wire 32 / reg2_data [31:0] $end
$var wire 1 * rst $end
$var wire 1 0 step5muxand $end
$var wire 32 1 write_reg_data [31:0] $end
$var wire 1 2 zero $end
$var wire 32 3 writeregmuxout [31:0] $end
$var wire 5 4 write_reg_addr [4:0] $end
$var wire 32 5 step5muxchan2 [31:0] $end
$var wire 32 6 step4muxout [31:0] $end
$var wire 32 7 shiftleft2 [31:0] $end
$var wire 1 8 regwriteregwrite $end
$var wire 1 9 regdstselectin $end
$var wire 32 : regdata2 [31:0] $end
$var wire 32 ; regdata1 [31:0] $end
$var wire 5 < reg2_addr [4:0] $end
$var wire 5 = reg1_addr [4:0] $end
$var wire 32 > pcadderout [31:0] $end
$var wire 32 ? pc_out [31:0] $end
$var wire 32 @ pc_in [31:0] $end
$var wire 1 A memwritedatamem $end
$var wire 1 B memtoregmux $end
$var wire 1 C memreaddatamem $end
$var wire 32 D instruction_out [31:0] $end
$var wire 6 E instr_opcode [5:0] $end
$var wire 1 F instr_extend $end
$var wire 32 G datamemmuxchan2 [31:0] $end
$var wire 1 H branchandmux $end
$var wire 1 I alusrcmux $end
$var wire 32 J aluout [31:0] $end
$var wire 2 K aluopaluctrl [1:0] $end
$var wire 32 L alumuxout [31:0] $end
$var wire 4 M aluctrloutalu [3:0] $end
$scope module ALU $end
$var wire 32 N channel_b_in [31:0] $end
$var wire 32 O channel_a_in [31:0] $end
$var wire 4 P alu_control_in [3:0] $end
$var reg 32 Q alu_result_out [31:0] $end
$var reg 32 R temp [31:0] $end
$var reg 1 2 zero_out $end
$upscope $end
$scope module ALUControl $end
$var wire 6 S instruction_5_0 [5:0] $end
$var wire 2 T alu_op [1:0] $end
$var reg 4 U alu_out [3:0] $end
$upscope $end
$scope module Control $end
$var wire 6 V instr_op [5:0] $end
$var reg 2 W alu_op [1:0] $end
$var reg 1 I alu_src $end
$var reg 1 H branch $end
$var reg 1 C mem_read $end
$var reg 1 B mem_to_reg $end
$var reg 1 A mem_write $end
$var reg 1 9 reg_dst $end
$var reg 1 8 reg_write $end
$upscope $end
$scope module MuxAlu $end
$var wire 32 X datain2 [31:0] $end
$var wire 1 I select_in $end
$var wire 32 Y datain1 [31:0] $end
$var wire 32 Z data_out [31:0] $end
$upscope $end
$scope module PC $end
$var wire 1 ) clk $end
$var wire 1 * rst $end
$var wire 1 ) write_en $end
$var wire 32 [ data_in [31:0] $end
$var reg 32 \ data_out [31:0] $end
$upscope $end
$scope module RAM $end
$var wire 1 ) clk $end
$var wire 8 ] data_address [7:0] $end
$var wire 1 A data_mem_write $end
$var wire 32 ^ data_read_data [31:0] $end
$var wire 32 _ instr_instruction [31:0] $end
$var wire 8 ` instr_read_address [7:0] $end
$var wire 1 * rst $end
$var wire 32 a data_write_data [31:0] $end
$upscope $end
$scope module Registers $end
$var wire 1 ) clk $end
$var wire 32 b read_data_1 [31:0] $end
$var wire 32 c read_data_2 [31:0] $end
$var wire 5 d read_register_1 [4:0] $end
$var wire 5 e read_register_2 [4:0] $end
$var wire 1 8 reg_write $end
$var wire 1 * rst $end
$var wire 5 f write_register [4:0] $end
$var wire 32 g write_data [31:0] $end
$var integer 32 h i [31:0] $end
$upscope $end
$scope module Step5 $end
$var wire 4 i alu_control_in [3:0] $end
$var wire 32 j channel_b_in [31:0] $end
$var wire 32 k channel_a_in [31:0] $end
$var reg 32 l alu_result_out [31:0] $end
$var reg 32 m temp [31:0] $end
$var reg 1 n zero_out $end
$upscope $end
$scope module WriteRegMux $end
$var wire 32 o datain1 [31:0] $end
$var wire 32 p datain2 [31:0] $end
$var wire 1 9 select_in $end
$var wire 32 q data_out [31:0] $end
$upscope $end
$scope module pc_adder $end
$var wire 4 r alu_control_in [3:0] $end
$var wire 32 s channel_a_in [31:0] $end
$var wire 32 t channel_b_in [31:0] $end
$var reg 32 u alu_result_out [31:0] $end
$var reg 32 v temp [31:0] $end
$var reg 1 w zero_out $end
$upscope $end
$scope module step4mux $end
$var wire 32 x datain1 [31:0] $end
$var wire 32 y datain2 [31:0] $end
$var wire 1 B select_in $end
$var wire 32 z data_out [31:0] $end
$upscope $end
$scope module step5mux $end
$var wire 32 { datain1 [31:0] $end
$var wire 32 | datain2 [31:0] $end
$var wire 1 0 select_in $end
$var wire 32 } data_out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100 }
b10000000 |
b100 {
bx z
bx y
bx x
0w
b100 v
b100 u
b100 t
b0 s
b10 r
b10 q
b0 p
b10 o
0n
b10000000 m
b10000000 l
b100 k
b1111100 j
b10 i
bx h
bx g
b10 f
b10 e
b0 d
bx c
bx b
bx a
b0 `
b10001100000000100000000000011111 _
bx ^
bx ]
b0 \
b100 [
b11111 Z
bx Y
b11111 X
b0 W
b100011 V
b10 U
b0 T
b11111 S
bx R
bx Q
b10 P
bx O
b11111 N
b10 M
b11111 L
b0 K
bx J
1I
0H
bx G
1F
b100011 E
b10001100000000100000000000011111 D
1C
1B
0A
b100 @
b0 ?
b100 >
b0 =
b10 <
bx ;
bx :
09
18
b1111100 7
bx 6
b10000000 5
b10 4
b10 3
x2
bx 1
00
bz /
bz .
b0 -
b0 ,
b0 +
1*
0)
b100011 (
b0 '
b0 &
b10 %
b10 $
bx #
bz "
bz !
$end
#50000
b11111 #
b11111 1
b11111 6
b11111 g
b11111 z
b101101001 G
b101101001 ^
b101101001 x
b11111 ]
02
b11111 J
b11111 Q
b11111 y
b11111 R
b0 :
b0 Y
b0 a
b0 c
b0 ;
b0 O
b0 b
b100000 h
1)
#100000
0*
0)
#105000
b100000 #
b100000 1
b100000 6
b100000 g
b100000 z
b10101110 G
b10101110 ^
b10101110 x
b100000 ]
b100000 J
b100000 Q
b100000 y
b100000 R
b11 f
b11 $
b11 4
b10000000 7
b10000000 j
b100000 L
b100000 N
b100000 Z
0F
b11 3
b11 q
b1000 @
b1000 [
b1000 }
b10001000 5
b10001000 l
b10001000 |
b10001000 m
b100000 X
b100000 S
b11 o
b11 %
b11 <
b11 e
b1000 >
b1000 k
b1000 u
b1000 {
b1000 v
b10001100000000110000000000100000 D
b10001100000000110000000000100000 _
b1 `
b100 '
b100 -
b100 ?
b100 \
b100 s
b0 :
b0 Y
b0 a
b0 c
1)
#110000
0)
#115000
b100 f
b100 $
b100 4
b0 G
b0 ^
b0 x
b111111 ]
b100 3
b100 q
b0 #
b0 1
b0 6
b0 g
b0 z
b1000000010000000 7
b1000000010000000 j
b111111 J
b111111 Q
b111111 y
b111111 R
b10 K
b10 T
b10 W
19
18
0I
0B
0C
b1100 @
b1100 [
b1100 }
b1000000010001100 5
b1000000010001100 l
b1000000010001100 |
b1000000010001100 m
b10000000100000 X
b100 p
b11111 ;
b11111 O
b11111 b
b10 &
b10 =
b10 d
b0 (
b0 E
b0 V
b1100 >
b1100 k
b1100 u
b1100 {
b1100 v
b10000110010000000100000 D
b10000110010000000100000 _
b10 `
b1000 '
b1000 -
b1000 ?
b1000 \
b1000 s
b100000 :
b100000 Y
b100000 a
b100000 c
1)
#116000
b1 ,
#120000
0)
#125000
b10000011 ]
b10000011 J
b10000011 Q
b10000011 y
b10000011 R
b110010000 7
b110010000 j
b1100100 L
b1100100 N
b1100100 Z
1I
18
b0 K
b0 T
b0 W
09
b10000 @
b10000 [
b10000 }
b110100000 5
b110100000 l
b110100000 |
b110100000 m
b1100100 X
b100100 S
b0 p
b100 o
b0 :
b0 Y
b0 a
b0 c
b100 %
b100 <
b100 e
b1000 (
b1000 E
b1000 V
b10000 >
b10000 k
b10000 u
b10000 {
b10000 v
b100000010001000000000001100100 D
b100000010001000000000001100100 _
b11 `
b1100 '
b1100 -
b1100 ?
b1100 \
b1100 s
1)
#126000
b10 ,
